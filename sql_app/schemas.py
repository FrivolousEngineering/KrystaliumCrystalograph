from typing import Optional, Union

from pydantic import BaseModel, Field, computed_field
from enum import Enum


class Action(str, Enum):
    """
    All the actions that a sample of raw Krystalium can have. Each sample of raw Krystalium has two actions;
    One positively charged action and one negatively charged action.

    In the case of refined Krystalium, it no longer has negative / positive charge, only two pairs of actions & targets.
    """
    expanding: str = "Expanding"
    contracting: str = "Contracting"
    conducting: str = "Conducting"
    insulating: str = "Insulating"
    deteriorating: str = "Deteriorating"
    creating: str = "Creating"
    destroying: str = "Destroying"
    increasing: str = "Increasing"
    decreasing: str = "Decreasing"
    absorbing: str = "Absorbing"
    releasing: str = "Releasing"
    solidifying: str = "Solidifying"
    lightening: str = "Lightening"
    encumbering: str = "Encumbering"
    fortifying: str = "Fortifying"
    heating: str = "Heating"
    cooling: str = "Cooling"


class Target(str, Enum):
    """
    All the targets that a sample of raw Krystalium can have. Each sample of raw Krystalium has two targets; One positively
    charged target and one negatively charged target.

    In the case of refined Krystalium, it no longer has negative / positive charge, only two pairs of actions & targets.
    """
    flesh: str = "Flesh"
    mind: str = "Mind"
    gas: str = "Gas"
    solid: str = "Solid"
    liquid: str = "Liquid"
    energy: str = "Energy"
    light: str = "Light"
    sound: str = "Sound"
    krystal: str = "Krystal"
    plant: str = "Plant"


class Vulgarity(str, Enum):
    """
    Vulgarity defines how stable a Krystalium sample is, with precious being most stable and vulgar being the least stable.

    When two traits (action or target) are the same, we call this 'invariant'.

    When two traits (action or target) are somewhat related (mind vs body, solid vs gas) we call it opposing. This is
    less stable than invariant, but more stable than conflicted.

    When two traits (action or target) are not related (not opposing and not the same), we call this conflicted.

    When both pairs are invariant, the substance is precious.
    When one of the pairs is invariant, it's semi-precious. High semi-precious have the other pair opposing, low has
    the other pair conflicting

    When all pairs are conflicting, it's vulgar.

    When there are no invariants, but one or two opposing, it's mundane (two opposing being high, one low)
    """
    vulgar = "Vulgar"
    low_mundane = "Low Mundane"
    high_mundane = "High Mundane"
    low_semi_precious = "Low Semi-Precious"
    high_semi_precious = "High Semi-Precious"
    precious = "Precious"

    @staticmethod
    def getScore(vulgarity: Union["Vulgarity", str]) -> int:
        return list(Vulgarity).index(vulgarity) + 1

    @staticmethod
    def getByScore(score: int) -> "Vulgarity":
        return list(Vulgarity)[score - 1]


class Purity(str, Enum):
    """
    Purity is calculated relatively simply. As we have 6 steps of vulgarity, we simply give precious a score of 6
    and vulgar a score of 1. We then just combine the score of both samples to find out the purity of the sample
    """

    polluted = "Polluted"
    tarnished = "Tarnished"
    dirty = "Dirty"
    blemished = "Blemished"
    impure = "Impure"
    unblemished = "Unblemished"
    lucid = "Lucid"
    stainless = "Stainless"
    pristine = "Pristine"
    immaculate = "Immaculate"
    perfect = "Perfect"

    @staticmethod
    def getScore(purity: Union["Purity", str]) -> int:
        return list(Purity).index(purity) + 2

    @staticmethod
    def getByScore(score: int) -> "Purity":
        return list(Purity)[score - 2]


class KrystaliumSampleBase(BaseModel):
    """
    Represents a raw Krystalium sample. Raw samples don't directly do something, instead they have two sets of actions
    and targets (negative and positive). When two samples are combined, one of the samples is places in the negative
    slot and the other in the positive slot. This will result in two sets of properties;

    The action of the negative is combined with the target of the positive and the target of the negative is combined
    with the action of the positive.
    """
    negative_action: Action = Field(description = "The negative action of the Krystalium sample")
    negative_target: Target = Field(description = "The negative target of the Krystalium sample")
    positive_action: Action = Field(description = "The positive action of the Krystalium sample")
    positive_target: Target = Field(description = "The positive target of the Krystalium sample")
    rfid_id: str = Field(description = "The ID of the physical RFID in the sample")


class RefinedKrystaliumBase(BaseModel):
    """
    Represents refined Krystalium, which are generated by combining two raw krystalium samples.

    When two samples are combined, one of the samples is places in the negative
    slot and the other in the positive slot. This will result in two sets of properties;

    The action of the negative is combined with the target of the positive and the target of the negative is combined
    with the action of the positive.
    """
    primary_action: Action = Field(description="The primary action of the refined Krystalium")
    primary_target: Target = Field(description="The primary target of the refined Krystalium")
    secondary_action: Action = Field(description="The secondary action of the refined Krystalium")
    secondary_target: Target = Field(description="The secondary target of the refined Krystalium")
    rfid_id: str = Field(description="The ID of the physical RFID in the sample")
    purity: Purity = Field(description="How pure / strong is the sample")


class RefinedKrystalium(RefinedKrystaliumBase):
    id: int

    @computed_field(description="The numerical representation of the purity. Two indicates polluted, 12 indicates perfect")
    @property
    def purity_score(self) -> int:
        return Purity.getScore(self.purity)

    class Config:
        orm_mode = True


class RefinedKrystaliumCreate(RefinedKrystaliumBase):
    pass


class KrystaliumSampleCreate(KrystaliumSampleBase):
    pass


class KrystaliumSample(KrystaliumSampleBase):
    id: int
    depleted: bool = Field(description="A Sample is depleted if it has been used to create refined Krystalium. It can no longer be used to create other refined samples")
    vulgarity: Vulgarity = Field()

    @computed_field(description="The numerical representation of the vulgarity. One indicates vulgar, 6 indicates precious")
    @property
    def vulgarity_score(self) -> int:
        return Vulgarity.getScore(self.vulgarity)

    class Config:
        orm_mode = True


class RefinedKrystaliumFromSample(BaseModel):
    positive_sample_rfid_id: str
    negative_sample_rfid_id: str
    refined_krystalium_rfid_id: str


class RandomKrystaliumSampleCreate(BaseModel):
    rfid_id: Optional[str] = Field(None, description="The ID of the physical RFID in the sample. This can not be set when creating multiple samples")
    vulgarity: Optional[Vulgarity] = Field(None, description="When set, it will create a sample with the given vulgarity. If not set, it will entirely randomly create one")
    num_samples: int = Field(1, description = "How many samples must be created. When this is set, rfid_id must be empty. This should only be used for debug purposes")


class BadRequestError(BaseModel):
    detail: str


class NotFoundError(BaseModel):
    detail: str
